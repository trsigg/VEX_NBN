#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    feedResistor,   sensorReflection)
#pragma config(Sensor, dgtl1,  flywheelEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  flywheelSwitch, sensorTouch)
#pragma config(Motor,  port1,           ce,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rb,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           er,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           us,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rfdrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rbdrive,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lfdrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           lbdrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           seymore,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          feedMe,        tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define driveTimer T2
#define fireTimer T3

int limit(int input, int min, int max) {
	if (input <= max && input >= min) {
		return input;
	}
	else {
		return (input > max ? max : min);
	}
}

void setDrivePower(int right, int left) {
	motor[rfdrive] = right;
	motor[rbdrive] = right;
	motor[lfdrive] = left;
	motor[lbdrive] = left;
}
//setLauncherPower
void setLauncherPower(int power, int minVal=0, int maxVal=127) {
	int flywheelPower = limit(power, minVal, maxVal);
	motor[ce] = flywheelPower;
	motor[rb] = flywheelPower;
	motor[er] = flywheelPower;
	motor[us] = flywheelPower;
}
//end setLauncherPower

//setFlywheelRange
float Integral=0, Ki=0, Kp=0, Kd=0; //also used in flywheelStabilization
int targetVelocity = 0; //also used in fire, seymoreControl, and flywheelStabilization
float firingErrorMargin; //also used in fire and seymoreControl

int velocities[4] = {0, 170, 185, 234};
float firingErrorMargins[4] = {0.1, 0.1, 0.1, 0.1};
float Kps[4] = {0, 2.6, 2.4, 56};
float Kis[4] = {0, 0.001, 0.001, 0.01};
float Kds[4] = {0, 1.5, 2.5, 80};

void setFlywheelRange(int range) {
	Integral = 0;
	int limitedRange = limit(range, 0, 4);
	Kp = Kps[limitedRange];
	Ki = Kis[limitedRange];
	Kd = Kds[limitedRange];
	targetVelocity = velocities[limitedRange];
}
//end setFlywheelRange

//turn
float degreesToTurn;
int maxTurnSpeed, waitAtEnd;

void turnEnd() {
	setDrivePower(-sgn(degreesToTurn) * 10, sgn(degreesToTurn) * 10);
	int brakeDelay = limit(250, 0, waitAtEnd);
	wait1Msec(brakeDelay);
	setDrivePower(0, 0);

	if (waitAtEnd > 250) wait1Msec(waitAtEnd - 250); //wait at end
}

task turnTask() {
	while (abs(SensorValue[gyro]) < abs(degreesToTurn * 10)) { EndTimeSlice(); }
	turnEnd();
}

void turn(float _degreesToTurn_, int _maxTurnSpeed_=55, bool runAsTask=false, int _waitAtEnd_=250) {
	degreesToTurn = _degreesToTurn_;
	maxTurnSpeed = _maxTurnSpeed_;
	waitAtEnd = _waitAtEnd_;

	SensorValue[gyro] = 0; //clear the gyro
	setDrivePower(sgn(degreesToTurn) * maxTurnSpeed, -sgn(degreesToTurn) * maxTurnSpeed); //begin turn

	if (runAsTask) {
		startTask(turnTask);
	}
	else {
		while (abs(SensorValue[gyro]) < abs(degreesToTurn * 10)) { EndTimeSlice(); }
		turnEnd();
	}
}
//end turn

//driveStraight
float coeff = 15;
bool driveStraightRunning = false;
int clicks, direction, drivePower, delayAtEnd, driveTimeout, totalClicks, slavePower, error;

void driveStraightRuntime() {
	setDrivePower(drivePower * direction, slavePower * direction);

	error = SensorValue[gyro];

	slavePower += error / coeff;

	totalClicks += (abs(SensorValue[leftEncoder]) + abs(SensorValue[rightEncoder])) / 2;
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
}

void driveStraightEnd() {
	setDrivePower(0, 0);
	wait1Msec(delayAtEnd);
	driveStraightRunning = false;
}

task driveStraightTask() {
	while (abs(totalClicks) < clicks  && time1(driveTimer) < driveTimeout) {
		driveStraightRuntime();

		wait1Msec(100);
	}
	driveStraightEnd();
}

void driveStraight(int _clicks_, int _delayAtEnd_=250, int _drivePower_=60, bool startAsTask=false, int _timeout_=15000) {
	//initialize global variables
	clicks = abs(_clicks_);
	direction = sgn(_clicks_);
	drivePower = _drivePower_;
	delayAtEnd = _delayAtEnd_;
	driveTimeout = _timeout_;

	totalClicks = 0;
	slavePower = drivePower - 2;
	error = 0;

	//initialize sensors
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	SensorValue[gyro] = 0;
	clearTimer(driveTimer);

	if (startAsTask) {
		startTask(driveStraightTask);
	}
	else { //runs as function
		while (abs(totalClicks) < clicks  && time1(driveTimer) < driveTimeout) {
			driveStraightRuntime();
			wait1Msec(100);
		}
		driveStraightEnd();
	}
}
//end driveStraight

//feed counting
int ballsInFeed; //also used in fire
int resistorCutoff = 100;

task feedCounting() {
	ballsInFeed = 0;
	while (true) {
		while (SensorValue[feedResistor] > resistorCutoff) { EndTimeSlice(); }
		while (SensorValue[feedResistor] < resistorCutoff) { EndTimeSlice(); }
		ballsInFeed++;
	}
}
//end feed counting

//fire counting
int ballsFired; //also used in fire

task fireCounting() {
	ballsInFeed = 0;
	while (true) {
		while (SensorValue[flywheelSwitch] == 0) { EndTimeSlice(); }
		while (SensorValue[flywheelSwitch] == 1) { EndTimeSlice(); }
		ballsFired++;
	}
}
//end fire counting

//fire
int ballsToFire, fireTimeout;

void fireRuntime() { motor[seymore] = (Error < targetVelocity * firingErrorMargin) ? 127 : 0; }

task fireTask() {
	while (ballsFired < ballsToFire && time1(fireTimer) < fireTimeout) {
		fireRuntime();
		EndTimeSlice();
	}
}

void fire(int _ballsToFire_=ballsInFeed, bool runAsTask=false, int _timeout_=6000) {
	fireTimeout = _timeout_;
	startTask(fireCounting);
	clearTimer(fireTimer);

	if (runAsTask) {
		startTask(fireTask);
	}
	else {
		while (ballsFired < ballsToFire && time1(fireTimer) < fireTimeout) { fireRuntime(); }
	}
}
//end fire

void pre_auton() { bStopTasksBetweenModes=true; }
task autonomous() { AutonomousCodePlaceholderForTesting(); }
task usercontrol() { UserControlCodePlaceholderForTesting(); }
