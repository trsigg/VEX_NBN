#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    chooResistor,   sensorReflection)
#pragma config(Sensor, in2,    two,            sensorPotentiometer)
#pragma config(Sensor, in3,    one,            sensorPotentiometer)
#pragma config(Sensor, in4,    sidePoten,      sensorPotentiometer)
#pragma config(Sensor, in5,    giraffeSetPoten, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  chooSwitch,     sensorDigitalIn)
#pragma config(Sensor, dgtl2,  feedSwitch,     sensorDigitalIn)
#pragma config(Sensor, I2C_1,  giraffeEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           feedMe,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           seymore,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           left1,         tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port4,           left2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           choo1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           choo3,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           right1,        tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port8,           right2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           choo2,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          giraffe,       tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define resistorSlope 0.37463777547902
#define resistorIntercept 781.44599343714
#define resistorShift 40
#define resistorSampleDelay 100
#define numResistorSamples 25

int resistorCutoff;

void setFeedPower(int power)
{
	motor[feedMe] = power;
	motor[seymore] = power;
}

task main()
{
	int feedPower = 60;
	float resistorAvg = SensorValue[chooResistor];
	for (int samples = 2; samples < numResistorSamples + 1; samples++)
	{
		resistorAvg = resistorAvg * (samples - 1) / samples + SensorValue[chooResistor] / samples;
		feedPower = (int)(1.02 * feedPower);
		setFeedPower(feedPower);
		wait1Msec(resistorSampleDelay);
	}
	resistorCutoff = (int)(resistorAvg * resistorSlope + resistorIntercept) - resistorShift;
	setFeedPower(0);
}
