#pragma config(Motor,  port1,           ce,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rb,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           er,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           us,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rfdrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rbdrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           lfdrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           lbdrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           feedMe,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          seymore,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int flywheelPower = 0;
int launcherDirection = 1; //1 when flywheel running, -1 for punchers

int targetPower = 0; //flywheel

#define feedInBtn Btn6U
#define feedOutBtn Btn6D

int limit(int input, int max, int min)
{
	if (abs(input) <= max && abs(input) >= min)
	{
		return input;
	}
	else
	{
		return ((abs(input) > max) ? (max * sgn(input)) : (min * sgn(input)));
	}
}

void setFeedPower(int power)
{
	motor[feedMe] = power;
	motor[seymore] = power;
}

void setDrivePower(int right, int left)
{
	motor[rfdrive] = right;
	motor[rbdrive] = right;
	motor[lfdrive] = left;
	motor[lbdrive] = left;
}

void setLauncherPower(int power)
{
	motor[ce] = limit(power, 0, 127) * launcherDirection; //TODO: calc. once then assign repeatedly
	motor[rb] = limit(power, 0, 127) * launcherDirection;
	motor[er] = limit(power, 0, 127) * launcherDirection;
	motor[us] = limit(power, 0, 127) * launcherDirection;
	flywheelPower = power;
}

task flywheel()
{
	while (targetPower == flywheelPower) { EndTimeSlice(); }
	while (targetPower - flywheelPower > 30)
	{
		setLauncherPower(flywheelPower + 30);
		wait1Msec(250);
	}
}

task flywheelControl()
{
	TVexJoysticks buttons[4] = {Btn7D, Btn7L, Btn7R, Btn7U};
	while (true)
	{
		for (int i = 0; i < 4; i++)
		{
			if (vexRT[buttons[i]] == 1)
			{
				targetPower = 60 + 20 * i;
			}
		}
	}
}

task feedControl()
{
	while (true)
	{
		while (vexRT[feedInBtn] == 0 && vexRT[feedOutBtn] == 0) { EndTimeSlice(); }
		if (vexRT[feedInBtn] == 1)
		{
			setFeedPower(127);
			while (vexRT[feedInBtn] == 1) { EndTimeSlice(); }
		}
		else
		{
			setFeedPower(-127);
			while (vexRT[feedOutBtn] == 1) { EndTimeSlice(); }
		}
		setFeedPower(0);
	}
}

task puncher()
{
	while (true)
	{
		while (vexRT[Btn5U] == 0) { EndTimeSlice(); }
		setLauncherPower(127);
		while (vexRT[Btn5U] == 1) { EndTimeSlice(); }
		setLauncherPower(0);
	}
}

task taskControl()
{
	while (true)
	{
		while (vexRT[Btn8U] == 0) { EndTimeSlice(); }
		launcherDirection = -launcherDirection;
		if (launcherDirection == 1)
		{
			stopTask(puncher);
			startTask(flywheel);
			startTask(flywheelControl);
		}
		else
		{
			stopTask(flywheel);
			stopTask(flywheelControl);
			startTask(puncher);
		}
	}
}

void initializeTasks()
{
	if (launcherDirection == 1)
	{
		startTask(flywheelControl);
		startTask(flywheel);
	}
	else
	{
		startTask(puncher);
	}
	startTask(feedControl);
	startTask(taskControl);
}

task main()
{
	while(true)
	{
		initializeTasks();
		while (vexRT[Btn8L] == 0)
		{
			setDrivePower(vexRT[Ch3], vexRT[Ch2]);
		}
	}
}
