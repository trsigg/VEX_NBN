#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           cebe,          tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           rus,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           feedMe,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           seymore,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           giraffe,       tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port6,           left1,         tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           left2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           right1,        tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port9,           right2,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

bool flywheelRunning = false; //taskControl
float flywheelTargetSpeed; //flywheel and fire
bool continuousFire = false; //fire

#define minDrivePower 20 //TO TEST
#define maxDrivePower 127
#define flywheelDefaultPower 100
#define flywheelGearRatio 100 //TO SET
#define sampleTime 50 //TO TUNE
#define kp 1 //TO TUNE
#define ki 1 //TO TUNE
#define kd 1 //TO TUNE
#define firingErrorMargin .05 //TO TUNE
#define bangBangErrorMargin .1 //TO TUNE
#define integralMargin .075 //TO TUNE
#define debounceTime 750

#define chooBtn Btn6U //TO SET
#define switchLauncherModesBtn Btn8D //TO SET
#define emergencyStopBtn Btn7L //TO SET
#define continuousFireBtn Btn5U //TO SET
#define fireOnceBtn Btn5D //TO SET
#define stopFireBtn Btn6D //TO SET

int limit(int input, int max, int min)
{
	if (abs(input) <= max && abs(input) >= min)
	{
		return input;
	}
	else
	{
		return ((abs(input) > max) ? (max * sgn(input)) : (min * sgn(input)));
	}
}

int maxPower()
{
	if (flywheelRunning)
	{
		//test max power ranges for different velocities
	}
	else
	{
		return 127;
	}
}

void initializeTasks()
{
	if (flywheelRunning)
	{
		startTask(flywheel);
		startTask(feedControl);
		startTask(taskControl);
	}
	else
	{
		startTask(cataChooChoo);
		startTask(taskControl);
	}
}

void resetPID()
{

}

//set functions region
void setFeedPower(int power)
{
	motor[feedMe] = power;
	motor[seymore] = power;
}

void setLauncherPower(int power) //set limits for different velocity ranges
{
	motor[cebe] = limit(power, 0, maxPower());
	motor[rus] = limit(power, 0, maxPower());
}

void setDrivePower(int right, int left)
{
	motor[right1] = right;
	motor[right2] = right;
	motor[left1] = left;
	motor[left2] = left;
}
//end set functions region

task flywheel()
{
	int prevError = flywheelTargetSpeed - /*velocity of flywheel motor*/;
	int error;
	int integral = 0;
	
	while (true)
	{
		while ((abs((flywheelTargetSpeed - /*velocity of flywheel motor*/) * gearRatio) < bangBangErrorMargin * flywheelTargetSpeed) //PID control
		{
			wait1Msec(sampleTime);
			error = (flywheelTargetSpeed - /*velocity of flywheel motor*/) * gearRatio;

			if (abs(error) < integralMargin * flywheelTargetSpeed)
			{
				integral += error;
			}

			setLauncherPower(flywheelDefaultPower + kp * error + ki * integral + kd * (error - prevError) / sampleTime);
			prevError = error;
		}

		//bang bang control
		resetPID(); //remove
		setLauncherPower((/*velocity of flywheel motor*/ < flywheelTargetSpeed) ? (127) : (0));

		while (abs(flywheelTargetSpeed - /*velocity of flywheel motor*/ * gearRatio) > bangBangErrorMargin * flywheelTargetSpeed) { EndTimeSlice(); }

		setLauncherPower(flywheelDefaultPower);
	}
}

task cataChooChoo()
{
	while (true)
	{
		while (vexRT[chooBtn] == 0) { EndTimeSlice(); }
		setLauncherPower(127);
		while (vexRT[chooBtn] == 1) { EndTimeSlice(); }
		setLauncherPower(0);
	}
}

task fire()
{
	do
	{
		while (abs(flywheelTargetSpeed - /*velocity of flywheel motor*/ * gearRatio) < firingErrorMargin * flywheelTargetSpeed) { EndTimeSlice(); } //waits for flywheel to be within an acceptable range of the target speed --- TODO: find velocity function

		setFeedPower(127);

	} while (continuousFire);
}

task taskControl()
{
	while (true)
	{
		while (vexRT[continuousFireBtn] == 0 && vexRT[fireOnceBtn] == 0 && vexRT[stopFireBtn] == 0 && vexRT[switchLauncherModesBtn] == 0) { EndTimeSlice(); }

		if (vexRT[continuousFireBtn] == 1)
		{
			continuousFire = true;
			startTask(fire);
		}
		else if (vexRT[fireOnceBtn] == 1)
		{
			continuousFire = false;
			startTask(fire);
		}
		else if (vexRT[stopFireBtn] == 1)
		{
			stopTask(fire);
		}
		else //switchLauncherModesBtn is pressed
		{
			setLauncherPower(0);
			bMotorReflected[cebe] = !bMotorReflected[cebe];
			bMotorReflected[rus] = !bMotorReflected[rus];

			if (flyWheelRunning)
			{
				stopTask(flywheel);
				startTask(cataChooChoo);
				stopTask(feedControl);
			}
			else
			{
				stopTask(cataChooChoo);
				startTask(flywheel);
				startTask(feedControl);
			}
		}

		wait1Msec(debounceTime);
	}
}

void pre_auton() { bStopTasksBetweenModes = true; }

void emergencyStop()
{
	stopTask(cataChooChoo);
	stopTask(taskControl);
	stopTask(flywheel);
	stopTask(

	startTask(userControl);
}

task autonomous()
{

}

task usercontrol()
{
	initializeTasks();

	while (true)
	{
		while (vexRT[emergencyStopBtn] == 0)
		{
			setDrivePower(vexRT[Ch2], vexRT[Ch3]);
			EndTimeSlice();
		}

		emergencyStop();
	}
}
