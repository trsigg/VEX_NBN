#pragma config(Sensor, dgtl1,  flywheelEncoder1, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  flywheelSwitch, sensorDigitalIn)
#pragma config(Sensor, dgtl8,  flywheelEncoder2, sensorQuadEncoder)
#pragma config(Sensor, dgtl10, feedSwitch,     sensorDigitalIn)
#pragma config(Motor,  port1,           ce,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rb,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           er,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           us,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rfdrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rbdrive,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lfdrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           lbdrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           feedMe,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          seymore,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define sampleTime 50. //number of milliseconds between sampling the flywheel velocity and control adjustments in flywheel task
#define adjustmentMaxDuration 750 //the maximum duration fo the adjustment period
#define seymoreDelay 750
//PID constants
#define kp 13.0 //12.6
#define ki 0.5 //.001
#define kd 5.0 //3.4
//error ranges
#define firingErrorMargin 0.04
#define bangBangErrorMargin 0.03
#define integralMargin 0.1
#define adjustmentMargin 0.04

#define fireBtn Btn5U
#define seymoreOutBtn Btn5D
#define toggleAutostopBtn Btn8U
#define feedInBtn Btn6U
#define feedOutBtn Btn6D

#define flywheelTimer T1
#define firingTimer T2
#define adjustmentTimer T3
#define miscTimer T4

bool automaticStop = false; //seymoreControl
//driveStraight
bool driveStraightRunning = false;
int clicks, rightDirection, leftDirection, drivePower, delayAtEnd, timeout; //driveStraight
//fire
int ballsToFire, shotsFired, fireTimeout;
bool fireRunning;
//flywheel variables
bool velocityUpdated = false;
bool adjustmentPeriod = false;
float flywheelVelocity = 0;
float targetVelocity = 0;
int flywheelPower = 0;

//debugging
float errorDebug;
int bangBangCount = 0;
int bbpercentup;
float bangBangPerSec = 0;
float avgError = 0;

//begin helper functions region
int limit(int input, int min, int max) {
	if (abs(input) <= max && abs(input) >= min) {
		return input;
	}
	else {
		return ((abs(input) > max) ? (max * sgn(input)) : (min * sgn(input)));
	}
}

task calcVelocity() {
	while (true) {
		SensorValue[flywheelEncoder1] = 0;
		SensorValue[flywheelEncoder2] = 0;
		wait1Msec(sampleTime);
		flywheelVelocity = abs((float)(SensorValue[flywheelEncoder1] + SensorValue[flywheelEncoder2])) / (float)(2 * sampleTime);
		velocityUpdated = true;
	}
}

task adjustmentPeriodTask() {
	adjustmentPeriod = true;
	clearTimer(adjustmentTimer);
	while (abs(targetVelocity - flywheelVelocity) < targetVelocity * adjustmentMargin && time1(adjustmentTimer) < adjustmentMaxDuration) { EndTimeSlice(); }
	adjustmentPeriod = false;
}
//end helper functions region

//set functions region
void setDrivePower(int right, int left) {
	motor[rfdrive] = right;
	motor[rbdrive] = right;
	motor[lfdrive] = left;
	motor[lbdrive] = left;
}

void setLauncherPower(int power) {
	flywheelPower = limit(power, 0, 127);
	motor[ce] = flywheelPower;
	motor[rb] = flywheelPower;
	motor[er] = flywheelPower;
	motor[us] = flywheelPower;
}

void setFlywheelRange(int range) {
	float velocities[5] = { 0.0, 7.00, 7.74, 8.79, 9.54 };
	targetVelocity = velocities[limit(range, 0, 4)];
}
//end set functions region

//autonomous region
task driveStraightTask()
{
	driveStraightRunning = true;

	int coeff = 5;
  int totalClicks = 0;
  int slavePower = drivePower;
  int error = 0;

  SensorValue[leftEncoder] = 0;
  SensorValue[rightEncoder] = 0;
  clearTimer(miscTimer);

  while(abs(totalClicks) < clicks && time1(miscTimer) < timeout)
  {
    setDrivePower(drivePower * leftDirection, slavePower * rightDirection);

    error = -SensorValue[leftEncoder] - SensorValue[rightEncoder];

    slavePower += error / coeff;

    totalClicks += SensorValue[leftEncoder];
    SensorValue[leftEncoder] = 0;
    SensorValue[rightEncoder] = 0;

    wait1Msec(100);
  }
  setDrivePower(0, 0);
  wait1Msec(delayAtEnd);
  driveStraightRunning = false;
}

void driveStraight(int _clicks_, int _leftDirection_, int _rightDirection_, int _drivePower_, int _delayAtEnd_=0, bool startAsTask=false, int _timeout_=2500) {
	clicks = _clicks_;
	rightDirection = _rightDirection_;
	leftDirection = _leftDirection_;
	drivePower = _drivePower_;
	delayAtEnd = _delayAtEnd_;
	timeout = _timeout_;
	if (startAsTask) {
		startTask(driveStraightTask);
	}
	else { //runs as function
		int coeff = 5;
	  int totalClicks = 0;
	  int slavePower = drivePower;
	  int error = 0;

	  SensorValue[leftEncoder] = 0;
	  SensorValue[rightEncoder] = 0;
	  clearTimer(miscTimer);

	  while(abs(totalClicks) < clicks  && time1(miscTimer) < timeout)
	  {
	    setDrivePower(drivePower * leftDirection, slavePower * rightDirection);

	    error = -SensorValue[leftEncoder] - SensorValue[rightEncoder];

	    slavePower += error / coeff;

	    totalClicks += SensorValue[leftEncoder];
	    SensorValue[leftEncoder] = 0;
	    SensorValue[rightEncoder] = 0;

	    wait1Msec(100);
	  }
	  setDrivePower(0, 0);
	  wait1Msec(delayAtEnd);
	}
}

task countShots() {
	shotsFired = 0;
	while (shotsFired < ballsToFire && time1(firingTimer) < fireTimeout) {
		while (SensorValue[flywheelSwitch] == 1) { EndTimeSlice(); }
		shotsFired++;
		while (SensorValue[flywheelSwitch] == 0) { EndTimeSlice(); }
	}
}

task fireTask() {
	fireRunning = true;
	clearTimer(firingTimer);
	startTask(countShots);

	while (shotsFired < ballsToFire && time1(firingTimer) < fireTimeout) {
		motor[seymore] = 127;
		while ((SensorValue[flywheelSwitch] == 1 || abs(targetVelocity - flywheelVelocity) < firingErrorMargin * targetVelocity) && time1(firingTimer) < fireTimeout) { EndTimeSlice(); }
		motor[seymore] = 0;
		while(!(SensorValue[flywheelSwitch] == 1 || abs(targetVelocity - flywheelVelocity) < firingErrorMargin * targetVelocity) && time1(firingTimer) < fireTimeout) { EndTimeSlice(); }
	}
	motor[seymore] = 0;
	fireRunning = false;
}

void fire(int _ballsToFire_, int _fireTimeout_=4000) {
		ballsToFire = _ballsToFire_;
		fireTimeout = _fireTimeout_;
		startTask(fireTask);
}
//end autonomous region

//begin user input region
task feedMeControl() {
	while (true) {
		while (vexRT[feedInBtn] == 0 && vexRT[feedOutBtn] == 0) { EndTimeSlice(); }
		if (vexRT[feedInBtn] == 1) {
			motor[feedMe] = 127;
			while (vexRT[feedInBtn] == 1) { EndTimeSlice(); }
		}
		else {
			motor[feedMe] = -127;
			while (vexRT[feedOutBtn] == 1) { EndTimeSlice(); }
		}
		motor[feedMe] = 0;
	}
}

task seymoreControl() {
	automaticStop = false;

	while (true) {
			while (SensorValue[feedSwitch] == 1 && vexRT[fireBtn] == 0 && vexRT[seymoreOutBtn] == 0 && vexRT[toggleAutostopBtn] == 0) {
			if (vexRT[fireBtn] == 1) { //firing
				stopTask(feedMeControl);
				motor[feedMe] = 127;
				while (vexRT[fireBtn] == 1) {
					motor[seymore] = (abs(flywheelVelocity - targetVelocity) < firingErrorMargin * targetVelocity || SensorValue[flywheelSwitch] == 1 ? 127 : 0);
					EndTimeSlice();
				}
				motor[feedMe] = 0;
				motor[seymore] = 0;
				startTask(feedMeControl);
			}
			else if (vexRT[seymoreOutBtn] == 1) { //feed out
				motor[seymore] = -127;
				while (vexRT[seymoreOutBtn] == 1) { EndTimeSlice(); }
				motor[seymore] = 0;
			}
			else if (SensorValue[feedSwitch] == 0) { //bottomFeedSwitch is pressed
				motor[seymore] = (SensorValue[flywheelSwitch] == 1 ? 127 : 0);
				while (SensorValue[flywheelSwitch] == 1 && SensorValue[feedSwitch] == 1 && vexRT[fireBtn] == 0 && vexRT[seymoreOutBtn] == 0) { EndTimeSlice(); }
				if (SensorValue[flywheelSwitch] == 1) {
					clearTimer(miscTimer);
					while (time1(miscTimer) < seymoreDelay && SensorValue[flywheelSwitch] == 1) { EndTimeSlice(); }
				}
				motor[seymore] = 0;
			}
			else { //toggleAutostopBtn is pressed
				automaticStop = !automaticStop;
				while (vexRT[toggleAutostopBtn] == 1]) { EndTimeSlice(); }
			}
		}
	}
}

task flywheel() {
	TVexJoysticks buttons[5] = {Btn8D, Btn7U, Btn7R, Btn7D, Btn7L};

	while (true) {
		for (int i = 0; i < 5; i++)	{
			if (vexRT[buttons[i]] == 1)	{
				setFlywheelRange(i);
				startTask(adjustmentPeriodTask);

				if (i == 4) {
					automaticStop = true;
				}
				else {
					automaticStop = false;
				}
			}
			EndTimeSlice();
		}
	}
}

task flywheelStabilization() { //modulates motor powers to maintain constant flywheel velocity
	clearTimer(flywheelTimer);
	float prevError = targetVelocity - flywheelVelocity;
	float error;
	float integral = 0;
	int numbbup = 0; //debug
	float totalError = 0;
	int numloops = 0;

	while (true)
	{
		while ((abs(targetVelocity - flywheelVelocity) < bangBangErrorMargin * flywheelVelocity && targetVelocity > 0) || adjustmentPeriod) //PID control
		{
			while (!velocityUpdated) { EndTimeSlice(); }
			error = (targetVelocity - flywheelVelocity);
			//debug
			errorDebug = error;
			totalError += abs(error);
    		numloops += 1;
    		avgError = totalError / numloops;

			velocityUpdated = false;

			if (abs(error) < integralMargin * flywheelVelocity)
			{
				integral += (prevError + error) * sampleTime / 2;
			}

			setLauncherPower(kp * error + ki * integral + kd * (error - prevError) / sampleTime);
			prevError = error;
		}

		//debug
		bangBangCount += 1;
		numbbup += (targetVelocity > flywheelVelocity ? 1 : 0);
		bbpercentup = 100 * numbbup / bangBangCount;
		bangBangPerSec = (float)((float)bangBangCount * 1000) / (float)(time1(flywheelTimer) + .1);

		//bang bang control
		while (abs(targetVelocity - flywheelVelocity) > bangBangErrorMargin * flywheelVelocity  * 0.75 && targetVelocity > 0 && !adjustmentPeriod) {
			setLauncherPower((targetVelocity > flywheelVelocity) ? (127) : ( 0));
			EndTimeSlice();
		}

		velocityUpdated = false;
		while (targetVelocity == 0) { EndTimeSlice(); } //pauses when flywheel is not powered
	}
}
//end user input region

//begin task control region
void resetFlywheelVars() {
	velocityUpdated = false;
	flywheelVelocity = 0;
	targetVelocity = 0;
	flywheelPower = 0;
}

void initializeTasks() {
	resetFlywheelVars();
	startTask(flywheel);
	startTask(flywheelStabilization);
	startTask(seymoreControl);
	startTask(calcVelocity);
	startTask(feedMeControl);
}

void emergencyStop() {
	stopTask(flywheel);
	stopTask(flywheelStabilization);
	stopTask(feedMeControl);
	stopTask(seymoreControl);
	stopTask(calcVelocity);

	initializeTasks();
}
//end task control region

void pre_auton() { bStopTasksBetweenModes = true; }

task autonomous() {
	//start flywheel
	initializeTasks();
	setFlywheelRange(4);
	//fire four initial preloads
	motor[feedMe] = 127;
	fire(4);
	while (fireRunning) { EndTimeSlice(); }

	setFlywheelRange(1);
	driveStraight(15, 1, -1, 50, 250); //turn to face first stack
	driveStraight(600, 1, 1, 100, 250); //pick up first stack
	driveStraight(5, -1, 1, 30, 250); //turn toward net
	//drive toward net
	driveStraight(800, 1, 1, 100, 500, true);
	while (driveStraightRunning) { EndTimeSlice(); }
	//fire first stack
	fire(3);
	while (fireRunning) { EndTimeSlice(); }


	driveStraight(1000, 1, 1, 100, 500); //drive over second stack to bar
	driveStraight(400, -1, -1, 100, 0, true); //aim for second stack
	while (driveStraightRunning) { EndTimeSlice(); }
	//fire second stack
	fire(3);
	while (fireRunning) { EndTimeSlice(); }

	//make sure all balls are cleared out
	motor[seymore] = 127;
	while (true){ EndTimeSlice(); }
}

task usercontrol() {
	stopTask(fireTask);
	initializeTasks();

	while (true)
	{
		while (true)
		{
			setDrivePower(sgn(vexRT[Ch2]) * vexRT[Ch2] * vexRT[Ch2] / 127, sgn(vexRT[Ch3]) * vexRT[Ch3] * vexRT[Ch3] / 127);
			EndTimeSlice();
		}

		emergencyStop(); //reassign emstop button
	}
}
