#pragma config(Sensor, dgtl1,  Flywheel,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  IntakeFeed,     sensorTouch)
#pragma config(Sensor, dgtl8,  FeedLaunch,     sensorTouch)
#pragma config(Sensor, dgtl9,  flywheelSwitch, sensorDigitalIn)
#pragma config(Motor,  port1,           ce,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rb,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           er,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           us,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           FRight,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           BRight,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           FLeft,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           BLeft,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           intkae,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          feed,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"	//Main competition background code...do not modify!

#define Kp 3	//TO TUNE
#define Ki 0.001	//TO TUNE
#define Kd 1.7	//TO TUNE


int power = 0;
float Flyspeed = 0;
int TargetSpeed = 0;
int setpower = 0;
int TargetSpeeds[5] = {0, 215, 300, 183, 191};	//ORIGINAL: {0, 205, 300, 183, 191}
//  TargetSpeeds[5] = {Off, Skillz, Long, 1st, 2nd}
int setpowers[5] = {0, 60, 96, 65, 68};
TVexJoysticks buttons[5] = {Btn8D, Btn7U, Btn7R, Btn7D, Btn7L};

//driveStraight
bool driveStraightRunning = false;
int clicks, rightDirection, leftDirection, drivePower, delayAtEnd, timeout;

int Flypower = 0;
int ToggleFeed = 1;
int ToggleIntkae = 1;
int n;

float P, I, D;

//helper functions region
int limit(int input, int min, int max) {
	if (input <= max && input >= min) {
		return input;
	}
	else {
		return (input > max ? max : min);
	}
}
//end helper functions region

//set functions region
void setLauncherPower(int power) {
	power = limit(power, 0, 127);
	motor[ce] = power;
	motor[rb] = power;
	motor[er] = power;
	motor[us] = power;
}
//end set functions region

void pre_auton() { bStopTasksBetweenModes = true; }


task motorcontrol()
{
	float Error = 0;
	float PrevError = 0;
	float Integral = 0;
	float DeltaE = 0;

	while(true)	{
		SensorValue[Flywheel] = 0;
		PrevError = Error;
		wait1Msec(25);

		Flyspeed = abs(SensorValue[Flywheel]);
		Error = TargetSpeed - Flyspeed;
		DeltaE = Error - PrevError;
		Integral += (Error + PrevError)/2;
		setLauncherPower(setpower + Kp*Error + Ki*Integral + Kd*DeltaE);

		//debug
		P = Kp*Error;
		I = Ki*Integral;
		D = Kd*DeltaE;
	}
}

task driveStraightTask()
{
	driveStraightRunning = true;

	int coeff = 5;
	int totalClicks = 0;
	int slavePower = drivePower;
	int error = 0;

	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	clearTimer(driveTimer);

	while (abs(totalClicks) < clicks && time1(driveTimer) < timeout)
	{
		setDrivePower(drivePower * leftDirection, slavePower * rightDirection);

		error = -SensorValue[leftEncoder] - SensorValue[rightEncoder];

		slavePower += error / coeff;

		totalClicks += SensorValue[leftEncoder];
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;

		wait1Msec(100);
	}
	setDrivePower(0, 0);
	wait1Msec(delayAtEnd);
	driveStraightRunning = false;
}

void driveStraight(int _clicks_, int _leftDirection_, int _rightDirection_, int _drivePower_, int _delayAtEnd_ = 0, bool startAsTask = false, int _timeout_ = 2500) {
	clicks = _clicks_;
	rightDirection = _rightDirection_;
	leftDirection = _leftDirection_;
	drivePower = _drivePower_;
	delayAtEnd = _delayAtEnd_;
	timeout = _timeout_;
	if (startAsTask) {
		startTask(driveStraightTask);
	}
	else { //runs as function
		int coeff = 5;
		int totalClicks = 0;
		int slavePower = drivePower;
		int error = 0;

		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
		clearTimer(driveTimer);

		while (abs(totalClicks) < clicks  && time1(driveTimer) < timeout)
		{
			setDrivePower(drivePower * leftDirection, slavePower * rightDirection);

			error = -SensorValue[leftEncoder] - SensorValue[rightEncoder];

			slavePower += error / coeff;

			totalClicks += SensorValue[leftEncoder];
			SensorValue[leftEncoder] = 0;
			SensorValue[rightEncoder] = 0;

			wait1Msec(100);
		}
		setDrivePower(0, 0);
		wait1Msec(delayAtEnd);
	}
}

task autonomous()
{
	TargetSpeed = 950;
	setpower = 104;
	startTask(motorcontrol);

	wait1Msec(1000);
	clearTimer(T1);
	while(true)
	{
		if(abs(Error) < 60)
		{
			motor[intkae] = 127;
			motor[feed] = 127;
		}
		else
		{
			motor[intkae] = 0;
			motor[feed] = 0;
		}
	}
}

task usercontrol()
{
	SensorValue[LEFT] = 0;
	SensorValue[RIGHT] = 0;
	startTask(motorcontrol);
	//startTask(FeedIntake);
	while(1)
	{
		Flypower = (power > 0 ? power : 0 );
		motor[intkae] = (ToggleIntkae == 1 ? (vexRT[Btn6U]*127 + vexRT[Btn6D]*-127) : 127);
		motor[feed] = (ToggleFeed == 1 ? (vexRT[Btn5U]*127 + vexRT[Btn5D]*-127) : 127);
		motor[BLeft] = vexRT[Ch3];
		motor[FLeft] = vexRT[Ch3];
		motor[BRight] = vexRT[Ch2];
		motor[FRight] = vexRT[Ch2];
		for (int i = 0; i < 5; i++)
		{
			n = (vexRT[buttons[i]] == 1 ? i : n);
		}
		if(n == 0)
		{
			Integral = 0;
		}
		TargetSpeed = TargetSpeeds[n];
		setpower = setpowers[n];
		Integral = vexRT[Btn8D] == 1 ? 0 : Integral;
	}
}
