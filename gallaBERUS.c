#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  flywheelEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  flywheelSwitch, sensorDigitalIn)
#pragma config(Sensor, dgtl10, feedSwitch,     sensorDigitalIn)
#pragma config(Motor,  port1,           ce,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rb,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           er,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           us,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           rfdrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rbdrive,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lfdrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           lbdrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           feedMe,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          seymore,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

#define sampleTime 50. //number of milliseconds between sampling the flywheel velocity and control adjustments in flywheel task
//PID constants
#define Kp 3.0
#define Ki 0.001
#define Kd 1.7
//error ranges
#define firingErrorMargin 0.01
#define bangBangErrorMargin 0.03
#define integralMargin 1.

#define fireBtn Btn5U
#define seymoreOutBtn Btn5D
#define toggleAutoStopBtn Btn8U
#define feedInBtn Btn6U
#define feedOutBtn Btn6D

#define flywheelTimer T1
#define firingTimer T2
#define driveTimer T3

bool automaticStop = false; //seymoreControl
//driveStraight
bool driveStraightRunning = false;
int clicks, rightDirection, leftDirection, drivePower, delayAtEnd, timeout; //driveStraight
//fire
int ballsToFire, shotsFired, fireTimeout;
bool fireRunning;
//turn
float degreesToTurn;
int direction, maxTurnSpeed, waitAtEnd;
//flywheel variables
bool adjustmentPeriod = false;
int flywheelVelocity = 0;
int targetVelocity = 0;
int flywheelPower = 0;

//glaaron
int defaultPower = 0;
int Integral  = 0;

//debugging
int seymoreState = 0;
float P, I, D;

//begin helper functions region
int limit(int input, int min, int max) {
	if (input <= max && input >= min) {
		return input;
	}
	else {
		return (input > max ? max : min);
	}
}
//end helper functions region

//set functions region
void setDrivePower(int right, int left) {
	motor[rfdrive] = right;
	motor[rbdrive] = right;
	motor[lfdrive] = left;
	motor[lbdrive] = left;
}

void setLauncherPower(int power) {
	flywheelPower = limit(power, 0, 127);
	motor[ce] = flywheelPower;
	motor[rb] = flywheelPower;
	motor[er] = flywheelPower;
	motor[us] = flywheelPower;
}

void setFlywheelRange(int range) {
	int velocities[5] = {0, 215, 300, 183, 191};
	int defaultPowers[5] = {0, 60, 96, 65, 68};

	Integral = 0;
	targetVelocity = velocities[limit(range, 0, 4)];
	defaultPower = defaultPowers[limit(range, 0, 4)];
}
//end set functions region

//autonomous region
task turnTask() {
	//clear the gyro
	SensorType[gyro] = sensorNone;
	wait1Msec(500);
	SensorType[gyro] = sensorGyro;
	wait1Msec(1000);

	//turn
	setDrivePower(direction * maxTurnSpeed, -direction * maxTurnSpeed);
	while (abs(SensorValue[gyro]) < degreesToTurn * 10) {}

	//brake
	setDrivePower(-direction * 10, direction * 10);
	int brakeDelay = limit(250, 0, waitAtEnd);
	wait1Msec(brakeDelay);
	setDrivePower(0, 0);

	if (waitAtEnd > 250) wait1Msec(waitAtEnd - 250); //wait at end
}

void turn(float _degreesToTurn_, int _direction_, int _maxTurnSpeed_ = 60, int _waitAtEnd_ = 250, bool runAsTask = false) { //direction: 1 for right turn, -1 for left turn
	degreesToTurn = _degreesToTurn_;
	direction = _direction_;
	maxTurnSpeed = _maxTurnSpeed_;
	waitAtEnd = _waitAtEnd_;

	if (runAsTask) {
		startTask(turnTask);
	}
	else {
		//clear the gyro
		SensorType[gyro] = sensorNone;
		wait1Msec(500);
		SensorType[gyro] = sensorGyro;
		wait1Msec(1000);

		//turn
		setDrivePower(direction * maxTurnSpeed, -direction * maxTurnSpeed);
		while (abs(SensorValue[gyro]) < degreesToTurn * 10) {}

		//brake
		setDrivePower(-direction * 10, direction * 10);
		int brakeDelay = limit(250, 0, waitAtEnd);
		wait1Msec(brakeDelay);
		setDrivePower(0, 0);

		if (waitAtEnd > 250) wait1Msec(waitAtEnd - 250); //wait at end
	}
}

task driveStraightTask()
{
	driveStraightRunning = true;

	int coeff = 5;
	int totalClicks = 0;
	int slavePower = drivePower;
	int error = 0;

	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	clearTimer(driveTimer);

	while (abs(totalClicks) < clicks && time1(driveTimer) < timeout)
	{
		setDrivePower(drivePower * leftDirection, slavePower * rightDirection);

		error = -SensorValue[leftEncoder] - SensorValue[rightEncoder];

		slavePower += error / coeff;

		totalClicks += SensorValue[leftEncoder];
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;

		wait1Msec(100);
	}
	setDrivePower(0, 0);
	wait1Msec(delayAtEnd);
	driveStraightRunning = false;
}

void driveStraight(int _clicks_, int _leftDirection_, int _rightDirection_, int _drivePower_, int _delayAtEnd_ = 0, bool startAsTask = false, int _timeout_ = 2500) {
	clicks = _clicks_;
	rightDirection = _rightDirection_;
	leftDirection = _leftDirection_;
	drivePower = _drivePower_;
	delayAtEnd = _delayAtEnd_;
	timeout = _timeout_;
	if (startAsTask) {
		startTask(driveStraightTask);
	}
	else { //runs as function
		int coeff = 5;
		int totalClicks = 0;
		int slavePower = drivePower;
		int error = 0;

		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;
		clearTimer(driveTimer);

		while (abs(totalClicks) < clicks  && time1(driveTimer) < timeout)
		{
			setDrivePower(drivePower * leftDirection, slavePower * rightDirection);

			error = -SensorValue[leftEncoder] - SensorValue[rightEncoder];

			slavePower += error / coeff;

			totalClicks += SensorValue[leftEncoder];
			SensorValue[leftEncoder] = 0;
			SensorValue[rightEncoder] = 0;

			wait1Msec(100);
		}
		setDrivePower(0, 0);
		wait1Msec(delayAtEnd);
	}
}

task fireTask() {
	int shotsFired = 0;
	clearTimer(firingTimer);
	motor[feedMe] = 127;
	motor[seymore] = 127;
	while (shotsFired < ballsToFire && time1(firingTimer) < fireTimeout) {
		while ((SensorValue[flywheelSwitch] == 1 || abs(targetVelocity - flywheelVelocity) < firingErrorMargin * targetVelocity) && time1(firingTimer) < fireTimeout) { EndTimeSlice(); }
		motor[seymore] = 0;
		shotsFired++;
		wait1Msec(1000);
		//while(!(SensorValue[flywheelSwitch] == 1 || abs(targetVelocity - flywheelVelocity) < firingErrorMargin * targetVelocity) && time1(firingTimer) < fireTimeout) { EndTimeSlice(); }
		motor[seymore] = 127;
	}
	motor[seymore] = 0;
}

void fire(int _ballsToFire_, int _fireTimeout_ = 4000) {
	ballsToFire = _ballsToFire_;
	fireTimeout = _fireTimeout_;
	startTask(fireTask);
}
//end autonomous region

//begin user input region
task feedMeControl() {
	while (true) {
		while (vexRT[feedInBtn] == 0 && vexRT[feedOutBtn] == 0) { EndTimeSlice(); }
		if (vexRT[feedInBtn] == 1) {
			motor[feedMe] = 127;
			while (vexRT[feedInBtn] == 1) { EndTimeSlice(); }
		}
		else {
			motor[feedMe] = -127;
			while (vexRT[feedOutBtn] == 1) { EndTimeSlice(); }
		}
		motor[feedMe] = 0;
	}
}

task seymoreControl() {
	while (true) {
		seymoreState = 0;
		while (vexRT[fireBtn] == 0 && vexRT[seymoreOutBtn] == 0 && vexRT[toggleAutoStopBtn] == 0) { EndTimeSlice(); }
		if (true) {
			seymoreState = 1;
			while (!(SensorValue[flywheelSwitch] == 1 || abs(targetVelocity - flywheelVelocity) < firingErrorMargin * targetVelocity || !automaticStop) && vexRT[fireBtn] == 1) { EndTimeSlice(); }
			motor[seymore] = 127;
			while ((SensorValue[flywheelSwitch] == 1 || abs(targetVelocity - flywheelVelocity) < firingErrorMargin * targetVelocity || !automaticStop) && vexRT[fireBtn] == 1) {
				if (SensorValue[flywheelSwitch] == 0) adjustmentPeriod = false;
				EndTimeSlice();
			}
		}
		else if (vexRT[seymoreOutBtn] == 1) {
			seymoreState = 2;
			motor[seymore] = -127;
			while (vexRT[seymoreOutBtn] == 1) { EndTimeSlice(); }
		}
		else {
			seymoreState = 3;
			automaticStop = !automaticStop;
			while (vexRT[toggleAutoStopBtn] == 1) { EndTimeSlice(); }
		}
		motor[seymore] = 0;
	}
}

task flywheel() {
	TVexJoysticks buttons[5] = { Btn8D, Btn7U, Btn7R, Btn7D, Btn7L }; //creating a pseudo-hash associating buttons with velocities and default motor powers

	while (true)
	{
		for (int i = 0; i < 5; i++)
		{
			if (vexRT[buttons[i]] == 1)
			{
				setFlywheelRange(i);
			}
			EndTimeSlice();
		}
	}
}

task flywheelStabilization() { //modulates motor powers to maintain constant flywheel velocity
	float Error = 0;
	float PrevError = 0;
	float Integral = 0;
	float DeltaE = 0;

	while(true)	{
		SensorValue[flywheelEncoder] = 0;
		PrevError = Error;
		wait1Msec(25);

		flywheelVelocity = abs(SensorValue[flywheelEncoder]);
		Error = targetVelocity - flywheelVelocity;
		DeltaE = Error - PrevError;
		Integral += (Error + PrevError)/2;
		setLauncherPower(defaultPower + Kp*Error + Ki*Integral + Kd*DeltaE);

		//debug
		P = Kp*Error;
		I = Ki*Integral;
		D = Kd*DeltaE;
	}
}
//end user input region

//begin task control region
void initializeTasks() {
	startTask(flywheel);
	startTask(flywheelStabilization);
	startTask(seymoreControl);
	startTask(feedMeControl);
}

void emergencyStop() {
	stopTask(flywheel);
	stopTask(flywheelStabilization);
	stopTask(feedMeControl);
	stopTask(seymoreControl);

	initializeTasks();
}
//end task control region

void pre_auton() { bStopTasksBetweenModes = true; }

task autonomous() {}

task usercontrol() {
	stopTask(fireTask);
	initializeTasks();

	while (true)
	{
		while (true)
		{
			setDrivePower(sgn(vexRT[Ch2]) * vexRT[Ch2] * vexRT[Ch2] / 127, sgn(vexRT[Ch3]) * vexRT[Ch3] * vexRT[Ch3] / 127);
			EndTimeSlice();
		}

		emergencyStop(); //reassign emstop button
	}
}
