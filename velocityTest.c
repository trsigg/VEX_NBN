#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  flywheelEncoder, sensorQuadEncoder)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           ce,            tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rb,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           er,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           us,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           rfd,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rbd,           tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           lfd,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           lbd,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           feedMe,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          seymore,       tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define feedInBtn Btn6U
#define feedOutBtn Btn6D
#define upTwentyBtn Btn5U
#define downTwentyBtn Btn5D
#define upTenBtn Btn5U
#define downTenBtn Btn5D
#define upFiveBtn Btn7U
#define downFiveBtn Btn7D
#define upOneBtn Btn8U
#define downOneBtn Btn8D

#define sampleTime 50

float velocity = 0.0;

int limit(int input, int max, int min)
{
	if (abs(input) <= max && abs(input) >= min)
	{
		return input;
	}
	else
	{
		return ((abs(input) > max) ? (max * sgn(input)) : (min * sgn(input)));
	}
}

void setFeedPower(int power)
{
	motor[feedMe] = power;
	motor[seymore] = power;
}

void setLauncherPower(int power) {
	int adjustedPower = limit(power, 0, 127);
	motor[ce] = adjustedPower;
	motor[rb] = adjustedPower;
	motor[er] = adjustedPower;
	motor[us] = adjustedPower;
}

void setDrivePower(int right, int left) {
	motor[rfd] = right;
	motor[rbd] = right;
	motor[lfd] = left;
	motor[lbd] = left;
}

void spinUp()
{
	for (int power = 30; power <= 90; power += 30)
	{
		setLauncherPower(power);
		wait1Msec(1000);
	}
}

task feedControl()
{
	while (true)
	{
		while (vexRT[feedInBtn] == 0 && vexRT[feedOutBtn] == 0) { EndTimeSlice(); }
		if (vexRT[feedInBtn] == 1)
		{
			setFeedPower(127);
			while (vexRT[feedInBtn] == 1) { EndTimeSlice(); }
		}
		else
		{
			setFeedPower(-127);
			while (vexRT[feedOutBtn] == 1) { EndTimeSlice(); }
		}
		setFeedPower(0);
	}
}

task calcVelocity()
{
	float velocities[5] = {0, 0, 0, 0, 0};
	while (true)
	{
		for (int i = 0; i < 5; i++)
		{
			SensorValue[flywheelEncoder] = 0;
			wait1Msec(sampleTime);
			velocities[i] = SensorValue[flywheelEncoder] / sampleTime;
			velocity = (velocities[0] + velocities[1] + velocities[2] + velocities[3] + velocities[4]) / 5;
		}
	}
}

task main()
{
	int power = 90;
	startTask(feedControl);
	startTask(calcVelocity);
	spinUp();
	while (true)
	{
		if (vexRT[upTwentyBtn])
		{
			power += 20;
			while (vexRT[upTwentyBtn] == 1) { EndTimeSlice(); }
		}
		else if (vexRT[upTenBtn])
		{
			power += 10;
			while (vexRT[upTenBtn] == 1) { EndTimeSlice(); }
		}
		else if (vexRT[upFiveBtn])
		{
			power += 5;
			while (vexRT[upFiveBtn] == 1) { EndTimeSlice(); }
		}
		else if (vexRT[upOneBtn])
		{
			power += 1;
			while (vexRT[upOneBtn] == 1) { EndTimeSlice(); }
		}
		else if (vexRT[downTwentyBtn])
		{
			power -= 20;
			while (vexRT[downTwentyBtn] == 1) { EndTimeSlice(); }
		}
		else if (vexRT[downTenBtn])
		{
			power -= 10;
			while (vexRT[downTenBtn] == 1) { EndTimeSlice(); }
		}
		else if (vexRT[downFiveBtn])
		{
			power -= 5;
			while (vexRT[downFiveBtn] == 1) { EndTimeSlice(); }
		}
		else if (vexRT[downOneBtn])
		{
			power -= 1;
			while (vexRT[downOneBtn] == 1) { EndTimeSlice(); }
		}

		setLauncherPower(power);
		setDrivePower(vexRT[Ch2], vexRT[Ch3]);
	}
}
