#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           cebe,          tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           rus,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           feedMe,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           seymore,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           giraffe,       tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port6,           left1,         tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           left2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           right1,        tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port9,           right2,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define feedInBtn Btn6U
#define feedOutBtn Btn6D
#define upTwentyBtn Btn5U
#define downTwentyBtn Btn5D
#define upTenBtn Btn5U
#define downTenBtn Btn5D
#define upFiveBtn Btn7U
#define downFiveBtn Btn7D
#define upOneBtn Btn8U
#define downOneBtn Btn8D

#define sampleTime 50.0

float velocity = 0.0;

int limit(int input, int max, int min)
{
	if (abs(input) <= max && abs(input) >= min)
	{
		return input;
	}
	else
	{
		return ((abs(input) > max) ? (max * sgn(input)) : (min * sgn(input)));
	}
}

void setFeedPower(int power)
{
	motor[feedMe] = power;
	motor[seymore] = power;
}

void setLauncherPower(int power)
{
	motor[cebe] = limit(power, 0, 127);
	motor[rus] = limit(power, 0, 127);
}

void spinUp()
{
	for (int power = 30, power <= 90, power += 30)
	{
		setLauncherPower(power);
		wait1Msec(1000);
	}
}

task feedControl()
{
	while (true)
	{
		while (vexRT[feedInBtn] == 0 && vexRT[feedOutBtn] == 0) { EndTimeSlice(); }
		if (vexRT[feedInBtn] == 1)
		{
			setFeedPower(127);
			while (vexRT[feedInBtn] == 1) { EndTimeSlice(); }
		}
		else
		{
			setFeedPower(-127);
			while (vexRT[feedOutBtn] == 1) { EndTimeSlice(); }
		}
		setFeedPower(0);
	}
}

task calcVelocity()
{
	float velocities[5] = {0, 0, 0, 0, 0};
	while (true)
	{
		for (int i = 0; i < 5; i++)
		{
			SensorValue[launcherEncoder] = 0;
			wait1Msec(sampleTime);
			velocities[i] = SensorValue[launcherEncoder] / sampleTime;
			velocity = (velocities[0] + velocities[1] + velocities[2] + velocities[3] + velocities[4]) / 5;
		}
	}
}

task main()
{
	int power = 90;
	spinUp();
	while (true)
	{
		if (vexRT[upTwentyBtn])
		{
			power += 20;
		}
		else if (vexRT[upTenBtn])
		{
			power += 10;
		}
		else if (vexRT[upFiveBtn])
		{
			power += 5;
		}
		else if (vexRT[upOneBtn])
		{
			power += 1;
		}
		else if (vexRT[downTwentyBtn])
		{
			power -= 20;
		}
		else if (vexRT[downTenBtn])
		{
			power -= 10;
		}
		else if (vexRT[downFiveBtn])
		{
			power -= 5;
		}
		else if (vexRT[downOneBtn])
		{
			power -= 1;
		}
	}
}
